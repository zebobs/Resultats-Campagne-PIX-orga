#    Ce programme fournit des fichiers synthétiques des résultats des campagnes PIX orga par classe.
#    Copyright (C) - 2021 - Denis Beaubiat
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

#    Modifié par Marius Monnier (Février 2022):
#    * ajout des filtres: campagnes archivées, campagnes personnelles
#    * ajout d'une fonction utilitaire pour tester le "(o/n)"
#    * correction d'un bug si l'utilisateur ne peut pas certifier.

import io
import os
from datetime import datetime


# Les bibliothèques au dessus sont standards dans python
# On vérifie la présence de requests et pandas qui sont obligatoires
# On vérifie la présence de xhtml2pdf qui est facultative (pour faire une sortie pdf et pas html)
# La sortie pdf ralentit considérablement l'éxécution

test_bibliotheque = True
test_pdf = True

try : 
    import requests
except:
    print("!!! Bibliothèque requests absente. Installez la bibliothèque requests. !!!")
    test_bibliotheque = False

try : 
    import pandas as pd
except:
    print("!!! Bibliothèque pandas absente. Installez la bibliothèque pandas. !!!")
    test_bibliotheque = False
    
if not(test_bibliotheque):
    print("!!! Le programme nécessite l'installation de bibliothèques python pour fonctionner !!!")
    quit()


try :
    from xhtml2pdf import pisa
except:
    print("!!! Bibliothèque xhtml2pdf absente. Pas de sortie pdf possible. Sortie en html !!!")
    test_pdf = False

def donnees_perso():
    username=input("Adresse mail associé à pix orga ? ")
    password=input("Mot de passe pix orga ? ")
    
    return username,password


def identification_orga(username,password):
    data={'username':username,'password':password,'grant_type':'password'}
    try :
        r = requests.post("https://orga.pix.fr/api/token", data)
        token = str(r.json()['access_token'])
        user_id=str(r.json()['user_id'])
        return token,user_id
    except:
        print("!!! Erreur de connexion à Pix Orga. Vérifier identifiant et mot de passe  !!!")
        quit()
        
def identification_certif(username,password):
    data={'username':username,'password':password,'grant_type':'password'}
    try :
        r = requests.post("https://certif.pix.fr/api/token", data)
        token = str(r.json()['access_token'])
        user_id=str(r.json()['user_id'])
        return token,user_id
    except:
        print("!!! Erreur de connexion à Pix Certif. Vérifier identifiant et mot de passe  !!!")
        quit()


def choix_organisation(token_orga,user_id):
    # Pour Pix Orga
    headers={'Authorization': 'Bearer '+ token_orga}
    r = requests.get("https://orga.pix.fr/api/prescription/prescribers/"+user_id, headers=headers)
    organisations=[]
    print("Nom des organisations auxquelles vous êtes rattaché dans pix orga")
    for c in r.json()['included']:
        if c['type']=='organizations':
            organisations.append(c)
            print("Identifiant | Nom")
            print( c['id'],"       |",c['attributes']['name'])
        
    if len(organisations)>1:
        print("Choisissez l'organisation à traiter")
        organisation_id=input("Identifiant :")
    elif len(organisations)==1:
        organisation_id=organisations[0]['id']

    organisation_id=str(organisation_id)
    return organisation_id


def choix_centre(token_certif):
    # Pour Pix Certif
    headers={'Authorization': 'Bearer '+ token_certif}
    r = requests.get("https://certif.pix.fr/api/certification-point-of-contacts/me", headers=headers)
    centres=[]
    print("Nom des centres auxquelles vous êtes rattaché dans pix certif")
    for c in r.json()['included']:
        if c['type']=='allowed-certification-center-access':
            centres.append(c)
            print("Identifiant | Nom")
            print( c['id'],"       |",c['attributes']['name'])
        
    if len(centres)>1:
        print("Choisissez l'organisation à traiter")
        centre_id=input("Identifiant :")
    elif len(centres)==1:
        centre_id=centres[0]['id']

    centre_id=str(centre_id)
    return centre_id



def liste_campagnes(token_orga,organisation_id,nb_campagnes_max=100,only_me=False, also_archived=False):
    #Pour Pix Orga
    headers={'Authorization': 'Bearer '+ token_orga}
    nb_campagnes_max = str(nb_campagnes_max)
    print("Récupération des résultats des dernières campagnes (max = "+nb_campagnes_max+" campagnes, archivées="+str(also_archived)+", personnelles="+str(only_me)+")")
    filters = '' # De base aucun filtre

    if only_me: # Si on veut seulement voir ses campagnes
        filters='&filter[isOwnedByMe]=true'

    r_actives = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/campaigns?page[number]=1"+filters+"&page[size]="+nb_campagnes_max, headers=headers)
    campagnes = r_actives.json()['data']
    if also_archived: # Si on veut voir aussi les campagnes archivées
        filters += '&filter[status]=archived'
        r_archived = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/campaigns?page[number]=1"+filters+"&page[size]="+nb_campagnes_max, headers=headers)
        campagnes += r_archived.json()['data']
    return campagnes

def liste_sessions(token_certif,centre_id,nb_sessions_max=200):
    #Pour Pix Certif
    headers={'Authorization': 'Bearer '+ token_certif}
    nb_sessions_max = str(nb_sessions_max)
    print("Récupération des sessions (max = "+nb_sessions_max+" sessions)")
    r = requests.get("https://certif.pix.fr/api/certification-centers/"+centre_id+"/session-summaries??page[number]=1&page[size]="+nb_sessions_max, headers=headers)
    
    
    sessions_info = []

    try : 
        for session in r.json()['data'] :
            s = requests.get("https://certif.pix.fr/api/sessions/"+session['id'], headers=headers)
            session_info=s.json()['data']['attributes']
            session_info['id']= session['id']
            session_info['Nombre de candidats inscrits'] = session['attributes']['enrolled-candidates-count']
            session_info['Nombre de candidats effectifs'] = session['attributes']['effective-candidates-count']
            sessions_info.append(session_info)
        sessions = pd.DataFrame.from_records(sessions_info)
        colonnes = {'address':'Nom du site','room':'Salle','examiner':'Surveillants','date':'Date big endian','time':'Heure','status':'Status','description':'Observations','access-code':"Code d'accès",'id':'Numéro Session','supervisor-password':'Mot de passe de session - Surveillant'}
        sessions.rename(columns = colonnes, inplace = True)
        sessions['Date'] = sessions.apply(lambda x : dateJMA(x['Date big endian']),axis=1)
    except :
        sessions = pd.DataFrame(None)    
    
    return sessions


# ff=[s['attributes'] for s in ss]
# a = pd.DataFrame.from_records(ff,exclude='')

def lecture_candidats_session(token_certif,centre_id,session,nb_eleves_max=3000):
    # Pour Pix Certif
    headers={'Authorization': 'Bearer '+ token_certif}
    session_id = session['Numéro Session']
    Date = session['Date']
    listecandidats = []
    
    # candidats_session = requests.get("https://certif.pix.fr/api/sessions/"+str(session_id)+"/certification-candidates", headers=headers)   
    # On utilise la fonction ajout qui donne la liste avec les classes
    r = requests.get("https://certif.pix.fr/api/certification-centers/"+centre_id+"/sessions/"+str(session_id)+"/students?&page[size]="+str(nb_eleves_max), headers=headers)       
    
    for c in r.json()['data']:
        
        if c['attributes']['is-enrolled'] :
            listecandidats.append((c['attributes']['division'],c['attributes']['last-name'],c['attributes']['first-name'],c['attributes']['birthdate'],Date))
    
    candidats_session=pd.DataFrame(listecandidats, columns=('Classe','Nom du Participant','Prénom du Participant','Birthdate',session_id))
    candidats_session.sort_values(by=['Classe', 'Nom du Participant','Prénom du Participant'],inplace = True)
    
    return candidats_session

def liste_candidats(token_certif,centre_id,sessions,resultats_globaux="",nb_eleves_max=3000) :
    # Pour Pix Certif
    print("Récupération de la liste des candidats (max = "+str(nb_eleves_max)+" élèves)")
    candidats=pd.DataFrame(columns=['Classe','Nom du Participant','Prénom du Participant','Birthdate'])
    
    if not(sessions.empty) :
        for index,session in sessions.iterrows() :
            
            candidats_session = lecture_candidats_session(token_certif,centre_id,session)
            candidats= pd.merge(left=candidats,right=candidats_session,how='outer',on=['Classe','Nom du Participant','Prénom du Participant','Birthdate'])
        
        candidats['Nb Convocations']=candidats.count(axis='columns')-4
        candidats['Date de naissance'] = candidats.apply(lambda x : dateJMA(x['Birthdate']),axis=1)
        candidats.sort_values(by=['Classe', 'Nom du Participant','Prénom du Participant'],inplace = True)
    
    if isinstance(resultats_globaux,str) :
        return candidats
    else :
        resultats_globaux = pd.merge(left=resultats_globaux,right=candidats.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','Nb Convocations']],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
        masque = resultats_globaux['Nombre de Pix validé'].notna()
        resultats_globaux['Nombre de Pix validé'] = resultats_globaux['Nombre de Pix validé'].where(masque,'-')
        return candidats,resultats_globaux 

def lecture_campagne(token_orga,campagne) :
    # Pour Pix Orga
    headers={'Authorization': 'Bearer '+ token_orga}
    donnees=[]
    
    r = requests.get("https://orga.pix.fr/api/campaigns/"+str(campagne['id']), headers=headers)
    token_pour_csv = r.json()['data']['attributes']['token-for-campaign-results']
    if campagne['attributes']['type']=='ASSESSMENT':
        type_campagne="assessment"
    elif campagne['attributes']['type']=='PROFILES_COLLECTION':
        type_campagne="profiles-collection"
    
    url_csv="https://orga.pix.fr/api/campaigns/"+str(campagne['id'])+"/csv-"+type_campagne+"-results?accessToken="+token_pour_csv+"&lang=fr"
    
    try :
        r = requests.get(url_csv)
        # permet de simuler le flux d'un fichier
        fichier_lecture =io.BytesIO(r.content)
        
    except:
        print("!!! Fichier csv en erreur de lecture. Campagne : "+campagne['attributes']['name']+" !!!")
        return "", ""
    
    try : 
        nom_fichier_csv=r.headers.get("Content-Disposition").split("filename=")[1]
        print(nom_fichier_csv)
        resultats = pd.read_csv(fichier_lecture,sep=';',quotechar='"',decimal=',',dtype={'Classe':'str'})        
        return campagne['attributes']['name'], resultats
    except:
        print("!!! Fichier csv en erreur de traitement. Campagne : "+campagne['attributes']['name']+" !!!")
        return "", ""

def export_pdf_attestations(token_orga,organisation_id) :
    # Pour Pix Orga
    print("!!! Traitement des pdf des certifications !!!")
    classes = liste_divisions(token_orga,organisation_id)
    headers={'Authorization': 'Bearer '+ token_orga}

    for classe in classes :
        classe = str(classe)
        try :
            r = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/certification-attestations?division="+classe, headers=headers)
            fichier_lecture =io.BytesIO(r.content)
            
        except:
            print("!!! Fichier pdf en erreur de lecture. Résutats certification : "+classe+" !!!")
        
        if r.status_code==200:
            os.makedirs("Attestations", exist_ok=True)
            fichier_ecriture = open("Attestations/Attestations-"+classe+".pdf","wb")
            fichier_ecriture.write(r.content)
            fichier_ecriture.close()
 
 
def lecture_traitement_resultats_certif(token_orga,organisation_id,resultats_globaux,eleves) :
    # Pour Pix Orga
    print("!!! Traitement des résultats des certifications !!!")
    classes = liste_divisions(token_orga,organisation_id)
    resultats=pd.DataFrame(columns=['Classe','Nom du Participant','Prénom du Participant','Statut','Nombre de Pix validé'])
    
    headers={'Authorization': 'Bearer '+ token_orga}

    for classe in classes :
        classe = str(classe)
        try :
            r = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/certification-results?division="+classe, headers=headers)
            fichier_lecture =io.BytesIO(r.content)
        
        except:
            print("!!! Fichier csv en erreur de lecture. Résutats certification : "+classe+" !!!")
        
        if r.status_code==200:
            resultats_classe = pd.read_csv(fichier_lecture,sep=';',quotechar='"',decimal=',',dtype={'Nombre de Pix':'string'})
            resultats_classe['Classe']=classe
            resultats_classe.rename(columns = {"Nom":"Nom du Participant","Prénom":"Prénom du Participant",'Nombre de Pix':'Nombre de Pix validé'}, inplace = True)
            resultats_classe = resultats_classe.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','Statut','Nombre de Pix validé']]
            
    # On indique les passation ayant eu un problème technique
            masque = resultats_classe['Nombre de Pix validé'] == '-'
            resultats_classe['Nombre de Pix validé'] = resultats_classe['Nombre de Pix validé'].where(~masque,"Pb passation")
            
            resultats = pd.merge(left=resultats,right=resultats_classe.loc[:,['Classe','Nom du Participant','Prénom du Participant','Statut','Nombre de Pix validé']],how='outer')
    
    # Les résultats de certifications contiennent les résultats d'élèves partis de l'établissement
    # On utilise la liste des élèves pour les retirer
    
    resultats = pd.merge(left=resultats,right=eleves,how='inner',on=['Classe', 'Nom du Participant','Prénom du Participant'])
    
    resultats_globaux = pd.merge(left=resultats_globaux,right=resultats.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','Nombre de Pix validé']],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
    
    
    return resultats, resultats_globaux

    
    
def liste_eleves(eleves_detail):
    #Pour Pix Orga
    
    return eleves_detail.loc[:,['Classe','Nom du Participant','Prénom du Participant']]

def liste_eleves_detail(token_orga,organisation_id,division="",nb_eleves_max=3000):
    #Pour Pix Orga
    print("Récupération de la liste des élèves (max = "+str(nb_eleves_max)+" élèves)")
    listeeleves = []
    
    filtre_classe =""
    if division !="" :
        filtre_classe="&filter[divisions][]="+division
    
    headers={'Authorization': 'Bearer '+ token_orga}  
    r = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/sco-participants?&page[size]="+str(nb_eleves_max)+filtre_classe, headers=headers)

    for e in r.json()['data']:
        listeeleves.append((e['attributes']['division'],e['attributes']['last-name'],e['attributes']['first-name'],e['attributes']['birthdate'],e['id'],e['attributes']['username'],e['attributes']['email'],e['attributes']['is-authenticated-from-gar'],e['attributes']['last-participation-date'],))
    
    eleves_detail=pd.DataFrame(listeeleves, columns=('Classe','Nom du Participant','Prénom du Participant','Birthdate','id','Identifiant','Adresse email','gar','Dernière connexion'))
    eleves_detail.sort_values(by=['Classe', 'Nom du Participant','Prénom du Participant'],inplace = True)
    
    
    return eleves_detail

def anonymat_mail(mail):
    decoupe=mail.split('@')
    return decoupe[0][0]+'...'+decoupe[0][-1]+'@'+decoupe[1]

def liste_identifiants(eleves_detail,resultats_globaux=""):
    print("!!! Traitement des identifiants                 !!!")
    eleves_detail['Identifiant']=eleves_detail[eleves_detail['Identifiant'].notna()]['Identifiant']
    eleves_detail['Adresse email']=eleves_detail[eleves_detail['Adresse email'].notna()]['Adresse email'].apply(anonymat_mail)
    eleves_detail.fillna('-')
    identifiants = eleves_detail.loc[:,['Nom du Participant','Prénom du Participant','Classe','Identifiant','Adresse email','gar','Dernière connexion']]

    if isinstance(resultats_globaux,str) :
        return identifiants
    else :
        resultats_globaux = pd.merge(left=resultats_globaux,right=identifiants.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','Nb Convocations']],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
        return identifiants,resultats_globaux


def liste_divisions(token_orga,organisation_id):
    #Pour Pix Orga
    divisions=[]
    
    headers={'Authorization': 'Bearer '+ token_orga}
    r = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/divisions", headers=headers)
    for e in r.json()['data']:
        divisions.append(e['id'])
       
    return divisions

def traitement_campagne(nom_campagne,resultats,resultats_globaux):
    # Mise en forme de colonne en pourcentage
    if '% de progression' in resultats.columns :
        # Recherche non finalisé
        masquenonfinalise=(resultats['% de progression']==1) & (resultats['Partage (O/N)']=="Non")
        resultats['% de progression'] = resultats['% de progression'].apply(lambda x: str(round(float(x)*100,1))+'%' if isinstance(x,(int,float)) else x)
    
    if "% maitrise de l'ensemble des acquis du profil" in resultats.columns :
        resultats.rename(columns = {"% maitrise de l'ensemble des acquis du profil":'% de réussite'}, inplace = True)
        resultats['% de réussite'] = resultats['% de réussite'].where(~masquenonfinalise,"Non finalisé")
        masque=pd.notna(resultats['% de réussite'])
        resultats['% de réussite'] = resultats['% de réussite'].where(masque,"En cours")
        resultats['% de réussite'] = resultats['% de réussite'].apply(lambda x: str(round(float(x)*100,1))+'%' if isinstance(x,(int,float)) else x)
        
        # Recensement résultats globaux
        resultats['% de réussite - ' + nom_campagne]=resultats['% de réussite']
        
        if not(resultats.empty):
            resultats_globaux = pd.merge(left=resultats_globaux,right=resultats.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','% de réussite - '+nom_campagne]],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
        
    
    # Pour traiter les campagnes de rentrée de type "Pour commencer ..."
    if 'Palier obtenu (/3)' in resultats.columns :
        resultats = resultats.loc[:,[ 'Classe','Nom du Participant','Prénom du Participant','% de progression','Palier obtenu (/3)','% de réussite']]
        resultats['Palier obtenu (/3)'] = resultats['Palier obtenu (/3)'].where(~(masquenonfinalise) ,'Non finalisé')
        masque=pd.notna(resultats['Palier obtenu (/3)'])
        resultats['Palier obtenu (/3)'] = resultats['Palier obtenu (/3)'].where(masque,'En cours')

    # Pour traiter la campagne de vérification des certifiables
    elif 'Certifiable (O/N)' in resultats.columns :
        resultats = resultats.loc[:,[ 'Classe','Nom du Participant','Prénom du Participant','Nombre de pix total','Nombre de compétences certifiables','Certifiable (O/N)',"Date de l'envoi"]]
        
        # Recensement résultats globaux
        if not(resultats.empty):
            masque=pd.notna(resultats['Certifiable (O/N)'])
            resultats['Certifiable (O/N)'] = resultats['Certifiable (O/N)'].where(masque,'Non finalisé')
            resultats_globaux = pd.merge(left=resultats_globaux,right=resultats.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','Certifiable (O/N)']],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
            print("!!! Ce message indique le traitement d'une récolte de profil.       !!!")
            print("!!! Il est souhaitable qu'il n'y en ait qu'une pour tous les élèves !!!") 

        
    # Pour traiter les autres campagnes
    else :
        resultats = resultats.loc[:,[ 'Classe','Nom du Participant','Prénom du Participant','% de progression','Partage (O/N)','% de réussite']]
        resultats.rename(columns = {'Partage (O/N)':'Finalisé (O/N)'}, inplace = True)        

    resultats_globaux['Connecté']='Oui'

    return resultats, resultats_globaux

def reinitialisation_mdp():
    # Propose de réinitialiser les mots de passe d'une classe
    # Cette fonction agit en écriture, elle ne doit pas être utilisée sauf cas exceptionnel
    classes = liste_divisions(token_orga,organisation_id)
    print("Listes des divisions : "+", ".join(classes))
    classe = input('Classe à réinitialiser : ')
    if classe not in classes :
        print(classe + " n'existe pas dans la liste des divisions")
        return
    reinitialisation_mdp_classe(classe,token_orga,organisation_id)

def reinitialisation_mdp_classe(classe,token_orga,organisation_id,sortie_html=True,sortie_pdf=False,sortie_csv=False) :
    # Cette fonction agit en écriture, elle ne doit pas être utilisée sauf cas exceptionnel
    # Attention la fonction contient la date de septemenbre 2022 codé en dur
    # A revoir
    print("!!! Réinitialisation des mots de passe des élèves de "+ classe + " ne s'étant pas identifié cette année scolaire et pas identifié par le GAR !!!")
    eleves_detail = liste_eleves_detail(token_orga,organisation_id,classe)
    eleves_detail['Dernière connexion']=eleves_detail['Dernière connexion'].apply(lambda x : dateAMint(x) if isinstance(x,str) else 0)
    masque = (eleves_detail['gar']==False ) & (  ~(eleves_detail['Identifiant'].isnull()) | ~(eleves_detail['Adresse email'].isnull()) ) & (eleves_detail['Dernière connexion']<202209 )
    
    eleves_a_reinit = eleves_detail[masque]
    headers={'Authorization': 'Bearer '+ token_orga}
    mdp= []
    for i in eleves_a_reinit.index :
        
        reinit = input(eleves_a_reinit['Nom du Participant'][i]+ " " +eleves_a_reinit['Prénom du Participant'][i]+" : réinitialiser le mdp o/n : ")
        if reinit == 'o' or reinit == 'O':
            payload={"data":{"attributes":{"organization-id":organisation_id,"organization-learner-id":eleves_a_reinit['id'][i]},"type":"dependent-users"}}
        # On crée un identifiant si on réinitialise le mdp à un élève sans identifiant
            if not isinstance(eleves_a_reinit['Identifiant'][i],str) :
                r = requests.post("https://orga.pix.fr/api/sco-organization-learners/username-password-generation", headers=headers,json=payload)
            r = requests.post("https://orga.pix.fr/api/sco-organization-learners/password-update", headers=headers,json=payload)
            mdp.append(r.json()['data']['attributes']['generated-password'])
        else :
            mdp.append("Non réinitialisé") 
            
    eleves_a_reinit.insert(5,'mdp',mdp)
    eleves_a_reinit = eleves_a_reinit[['Classe','Nom du Participant','Prénom du Participant','mdp']]

    # On récupère la liste avec les identifiants mis à jour
    eleves_detail = liste_eleves_detail(token_orga,organisation_id,classe)
    eleves_detail=eleves_detail[['Classe','Nom du Participant','Prénom du Participant','Identifiant']]
    
    sortie_par_classe(classe+"-réinitialisation mdp",eleves_a_reinit,eleves_detail,sortie_html,sortie_pdf,sortie_csv)
    
    return eleves_a_reinit

def traitement_synthese(resultats_globaux,eleves):
    print("!!! Traitement de la synthèse                   !!!")
    
    # Avant avant avant dernière colonne Certifiable O/N
    if 'Connecté' in resultats_globaux.columns :
        column_to_reorder = resultats_globaux.pop('Connecté')
        resultats_globaux.insert(len(resultats_globaux.columns), 'Connecté', column_to_reorder)
    
    
    # Avant avant dernière colonne Certifiable O/N
    if 'Certifiable (O/N)' in resultats_globaux.columns :
        column_to_reorder = resultats_globaux.pop('Certifiable (O/N)')
        resultats_globaux.insert(len(resultats_globaux.columns), 'Certifiable (O/N)', column_to_reorder)

    # Avant avant dernière colonne Nb Convocations
    if 'Nb Convocations' in resultats_globaux.columns :
        column_to_reorder = resultats_globaux.pop('Nb Convocations')
        resultats_globaux.insert(len(resultats_globaux.columns), 'Nb Convocations', column_to_reorder)

    # Dernière colonne résultats de la certification
    if 'Nombre de Pix validé' in resultats_globaux.columns :
        column_to_reorder = resultats_globaux.pop('Nombre de Pix validé')
        resultats_globaux.insert(len(resultats_globaux.columns), 'Nombre de Pix validé', column_to_reorder)

    # Fusion avec la liste de tous les élèves pour permettre la synthèse sur toutes les classes même celles sans élèves ayant répondu
    # On enlève les élèves qui ne sont plus dans l'établissement
    resultats_globaux=resultats_globaux.merge(eleves,how='inner',on=['Classe', 'Nom du Participant','Prénom du Participant'])

    return resultats_globaux

def formatageA4portrait(taille_police=12):
    taille_police2 = str(taille_police + 2)
    taille_police4 = str(taille_police + 4)
    taille_police = str(taille_police)
    # Format A4 595 x 842 px
    formatageA4portrait = '<style type="text/css">'\
    ' @page {@frame content_frame {left: 28pt;width: 539pt;top: 28pt;height: 786pt;-pdf-frame-border: 1;}'\
    ' size: A4 portrait}'\
    ' h1 {font-size: '+taille_police4+'px}'\
    ' h2 {font-size: '+taille_police2+'px}'\
    ' h1, h2, h3 {margin-bottom: 0;}'\
    ' body,p,h3 {font-size: '+taille_police+'px}'\
    ' table{ font-size: '+taille_police+'px ;font-family: sans-serif; border-collapse: collapse;  }'\
    ' td, th{border: 1px solid #ddd; padding: 3px;}'\
    ' th{text-align: left;  background-color: #1e7375;  color: white;}'\
    ' tr{padding:1px}'\
    ' tr:nth-child(even){background-color: #f2f2f2;}'\
    ' a{text-decoration:none; color:black; }'\
    ' </style>'
    return formatageA4portrait

def formatageA4paysage(taille_police=11):
    taille_police2 = str(taille_police + 2)
    taille_police4 = str(taille_police + 4)
    taille_police = str(taille_police)    
    formatage = '<style type="text/css">'\
    ' @page {@frame content_frame {left: 28pt;width: 786pt;top: 28pt;height: 539pt;-pdf-frame-border: 1;}'\
    ' size: A4 landscape}'\
    ' h1 {font-size: '+taille_police4+'px}'\
    ' h2 {font-size: '+taille_police2+'px}'\
    ' h1, h2, h3 {margin-bottom: 0;}'\
    ' body,p,h3 {font-size: '+taille_police+'px}'\
    ' table{ font-size: '+taille_police+'px ;font-family: sans-serif; border-collapse: collapse; }'\
    ' td, th{border: 1px solid #ddd; vertical-align : middle; padding : 1px; }'\
    ' th{text-align: left;  background-color: #1e7375;  color: white;}'\
    ' tr:nth-child(even){background-color: #f2f2f2;}'\
    ' a{text-decoration:none; color:black; }'\
    ' </style>'
    return formatage

def sortie_par_classe(nom_campagne,resultats,eleves,sortie_html=True,sortie_pdf=False,sortie_csv=False,formatage='portrait',test_pdf=test_pdf):
    sortie_html= (sortie_pdf and not(test_pdf)) or sortie_html
    sortie_pdf= sortie_pdf and test_pdf
    
    resultats.sort_values(by=['Classe', 'Nom du Participant','Prénom du Participant'],inplace = True)
    liste_des_classes = resultats['Classe'].unique()
    

    # Fusion avec la liste de tous les élèves
    resultats=resultats.merge(eleves,how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])

    if formatage == 'paysage':
        formatage = formatageA4paysage()
    else :
        formatage = formatageA4portrait()
    
    titre = nom_campagne +" - "+ datetime.now().strftime('%Y-%m-%d')

    texte_HTML=formatage +'<h1>'+ titre +'</h1><p><a name="haut">Cliquer sur la classe pour voir la synthèse des résultats<a></p>'
    
    # Liste des classes à cliquer
    if len(liste_des_classes)>0:
        texte_HTML += '<table><tr>'
        n=1
        for classe in liste_des_classes :
            # Les élèves qui sont déliés de l'établissement n'ont pas de classe, on ne les affiche pas.
            if not(pd.isna(classe)) :
                texte_HTML += '<td><a href="#'+classe+'">'+ classe +'</a></td>'
                if n%6==0 and n != len(liste_des_classes) :
                        texte_HTML +='</tr><tr> '
                        
                n+=1    
        
        texte_HTML +='</tr></table><div style="page-break-before:always">&nbsp;</div>'
    
    # Liste des résultats par classe
    for classe in liste_des_classes :
         # Les élèves qui sont déliés de l'établissement n'ont pas de classe, on ne les affiche pas.
         
         if not(pd.isna(classe)) : 
            resultats_classe = resultats[resultats['Classe']==classe].dropna(how='all',axis='columns')
            texte_HTML += '<h2><a name="'+classe+'">'+ classe +' - '+ titre+'</a> - <a href="#haut"> <span style="font-weight: normal;"> retour liste</span></a></h2>'+ resultats_classe.to_html(index=False,na_rep="-")+ '<div style="page-break-before:always">&nbsp;</div>'
    
    # Modification pour la largeur de la colonne
    texte_HTML = texte_HTML.replace("<th>Classe</th>","<th style='width:70px;'>Classe</th>")
    
    # Traitement des caractères interdits dans un nom de fichier
    dico=titre.maketrans('\/:*?"<>|','---------')
    nom_du_fichier = titre.translate(dico)
    
    repertoire = datetime.now().strftime('%Y-%m-%d')
    os.makedirs(repertoire, exist_ok=True)
    
    ecriture_sorties(nom_du_fichier,repertoire,texte_HTML,resultats,sortie_html,sortie_pdf,sortie_csv)
    

def ecriture_sorties(nom_du_fichier,repertoire,texte_HTML,tableau,sortie_html,sortie_pdf,sortie_csv,test_pdf=test_pdf):
    sortie_html= (sortie_pdf and not(test_pdf)) or sortie_html
    sortie_pdf= sortie_pdf and test_pdf

    if sortie_html :
        fichier_HTML = open(repertoire+"/"+nom_du_fichier+'.html', "w")
        fichier_HTML.write(texte_HTML)
        fichier_HTML.close()

    if sortie_pdf :
        fichier_PDF = open(repertoire+"/"+nom_du_fichier+ '.pdf', "w+b")
        pisa.CreatePDF(texte_HTML,fichier_PDF)
        fichier_PDF.close()
        
    if sortie_csv:
        tableau.fillna(value="-", inplace=True)
        tableau.to_csv(repertoire+"/"+nom_du_fichier+'.csv',index=False,sep=';',quotechar='"',encoding='utf-8',)



def liste_sessions_detail(sessions,candidats,contexte='orga',sortie_html=False,sortie_pdf=True,sortie_csv=False):

    classes_concernees = []
    for session_id in sessions['Numéro Session'] :
        candidats_session=candidats[candidats[session_id].notna()]
        classes_concernees.append(', '.join(candidats_session['Classe'].unique()))
    sessions["Classes concernées"] = classes_concernees
    sessions['Classes concernées']= sessions['Classes concernées'].replace('','-')
    sessions['Observations']= sessions['Observations'].replace('','-')
    sessions['Salle']= sessions['Salle'].replace('','-')
    sessions['Surveillants']= sessions['Surveillants'].replace('','-')
    
    # Pour créer un sortie pdf, html
    titre = ['Liste des sessions à venir']
    liste = [sessions[sessions['Status']=='created'].loc[:,['Date','Heure','Salle','Classes concernées','Observations','Nombre de candidats inscrits','Surveillants','Numéro Session' ]].to_html(index=False)]

    if contexte == 'certif'  :
        titre.append("Liste des sessions à venir - Document réservé aux administrateurs - Présence des codes d'accès")
        liste.append(sessions[sessions['Status']=='created'].loc[:,['Date','Heure','Salle','Classes concernées','Observations','Nombre de candidats inscrits','Surveillants','Numéro Session',"Code d'accès" ]].to_html(index=False))
    
    
    for i in range(len(titre)) :

        texte_HTML = formatageA4paysage() +'<h1>'+titre[i]+'</h1>' + liste[i]
        texte_HTML = texte_HTML.replace("<th>Date</th>","<th style='width:70px;'>Date</th>")
        texte_HTML = texte_HTML.replace("<th>Heure</th>","<th style='width:70px;'>Heure</th>")
        texte_HTML = texte_HTML.replace("<th>Nombre de candidats inscrits</th>","<th style='width:70px;'>Nombre de candidats inscrits</th>")
        texte_HTML = texte_HTML.replace("<th>Numéro Session</th>","<th style='width:70px;'>Numéro Session</th>")
        texte_HTML = texte_HTML.replace("<th>Code d'accès</th>","<th style='width:70px;'>Code d'accès</th>")
        
        if contexte == 'certif'  :
            repertoire = 'Documents-Certif-Auto'
        else :
            repertoire = datetime.now().strftime('%Y-%m-%d')
            
        os.makedirs(repertoire, exist_ok=True)    
        ecriture_sorties(titre[i],repertoire,texte_HTML,'',sortie_html,sortie_pdf,False)

    return sessions


def gestion_reconvocations(resultats_globaux,sortie_html,sortie_pdf,code_collecte_profils=""):
    # Cette fonction n'est pas très pertinente tant qu'elle ne gère pas
    # les élèves dont la certif est à venir
    # L'utilisation du csv de synthèse est plus utile
    if 'Nombre de Pix validé' not in resultats_globaux.columns  :
        print('!!! Aucun résultat de session reçu !!!')
    print('!!! Gestion des reconvocations              !!!')
    texte_HTML  = "<h1>Résumé du déroulement des certifications au "+ datetime.now().strftime('%d/%m/%Y') + "</h1>"
    texte_HTML += "<p>Attention ne tient compte que des classes dans lesquelles 1 élève au moins a été convoqué</p>"
    texte_HTML += "<p>Et considère que toutes les certifications prévues ont eu lieu</p>"
    classes_convoquees = resultats_globaux[resultats_globaux['Nb Convocations']>0]['Classe'].unique()
    texte_HTML += "<p>"+str(len(classes_convoquees)) +" Classes convoquées : "+", ".join(classes_convoquees)+".<p>"
    
    eleves_classes_convoquees=resultats_globaux[resultats_globaux['Classe'].isin(classes_convoquees)]
    texte_HTML += "<p>"+str(len(eleves_classes_convoquees)) +" élèves convoqués.</p>"
    
    non_convoques = eleves_classes_convoquees [pd.isna(eleves_classes_convoquees['Nb Convocations'])]
    if len(non_convoques) > 0 :
        texte_HTML += "<p>"+str(len(non_convoques)) +" élèves non convoqués. Probablement une arrivée tardive.</p>"
        texte_HTML += "<p>A convoquer manuellement</p>"
        texte_HTML += non_convoques.loc[:,['Classe','Nom du Participant','Prénom du Participant']].to_html(index_names=False,index=False,header=False)
    
    non_certifies = eleves_classes_convoquees [eleves_classes_convoquees['Nombre de Pix validé']==0]
    texte_HTML += "<p>"+str(len(non_certifies)) +" élèves non certifiés. L'élève a fait faux à plus de la moitié des questions ou n'a pas fini.</p>"

    a_convoquer1 = eleves_classes_convoquees [(pd.isna(eleves_classes_convoquees['Nombre de Pix validé'])) & (eleves_classes_convoquees['Nb Convocations']<2)]
    texte_HTML += "<p>"+str(len(a_convoquer1)) +" élèves à reconvoquer (1e reconvocation) dont</p>"
    
    a_convoquer1_non_connectes = a_convoquer1[a_convoquer1['Connecté']!='Oui']
    classe_a_convoquer1_non_connectes = a_convoquer1_non_connectes['Classe'].value_counts(ascending=True).index.tolist()
    texte_HTML += "<ul><li>"+str(len(a_convoquer1_non_connectes)) +" élèves jamais connecté. Descolarisé ?</li>"
    
    a_convoquer1_connectes_non_certifiables = a_convoquer1[(a_convoquer1['Certifiable (O/N)']!='Oui') & (a_convoquer1['Connecté']=='Oui')]
    classe_a_convoquer1_connectes_non_certifiables = a_convoquer1_connectes_non_certifiables['Classe'].value_counts(ascending=True).index.tolist()
    texte_HTML += "<li>"+str(len(a_convoquer1_connectes_non_certifiables)) +" élèves non certifiables. Doivent améliorer leur positionnement et renvoyer leur profil</li>"
    
    a_convoquer1_certifiables = a_convoquer1[a_convoquer1['Certifiable (O/N)']=='Oui']
    classe_a_convoquer1_certifiables = a_convoquer1_certifiables['Classe'].value_counts(ascending=True).index.tolist()
    texte_HTML += "<li>"+str(len(a_convoquer1_certifiables)) +" élèves certifiables. À reconvoquer rapidement</li>"

    a_convoquer2 = eleves_classes_convoquees [(pd.isna(eleves_classes_convoquees['Nombre de Pix validé'])) & (eleves_classes_convoquees['Nb Convocations']>1)]
    classe_a_convoquer2 = a_convoquer2['Classe'].value_counts(ascending=True).index.tolist()
    texte_HTML += "<li>"+str(len(a_convoquer2)) +" élèves convoqués 2 fois et sans résultats (motifs possibles : absents, pas certifiables, oublis de compte) </li>"


    texte_HTML += '</tr></table><div style="page-break-before:always">&nbsp;</div>'
    texte_HTML += "<h1>Élèves à reconvoquer (1e fois) pas connectés cette année</h1>"
    for nom_classe in classe_a_convoquer1_non_connectes :
        liste = a_convoquer1_non_connectes[a_convoquer1_non_connectes['Classe']==nom_classe]        
        texte_HTML += nom_classe+"<br>"
        texte_HTML += liste.loc[:,['Nom du Participant','Prénom du Participant']].to_csv(index=False,header=False)+"<br>"
        
    texte_HTML += '</tr></table><div style="page-break-before:always">&nbsp;</div>'
    texte_HTML += "<h1>Élèves à reconvoquer (1e fois) pas certifiables</h1>"
    for nom_classe in classe_a_convoquer1_connectes_non_certifiables :
        liste = a_convoquer1_connectes_non_certifiables[a_convoquer1_connectes_non_certifiables['Classe']==nom_classe]
        texte_HTML += nom_classe+"<br>"
        texte_HTML += liste.loc[:,['Nom du Participant','Prénom du Participant']].to_csv(index=False,header=False)+"<br>"
        
    texte_HTML += '</tr></table><div style="page-break-before:always">&nbsp;</div>'
    texte_HTML += "<h1>Élèves à reconvoquer (1e fois) certifiables</h1>"
    for nom_classe in classe_a_convoquer1_certifiables :
        liste = a_convoquer1_certifiables[a_convoquer1_certifiables['Classe']==nom_classe]        
        texte_HTML += nom_classe+"<br>"
        texte_HTML += liste.loc[:,['Nom du Participant','Prénom du Participant']].to_csv(index=False,header=False)+"<br>"
        
    texte_HTML += '</tr></table><div style="page-break-before:always">&nbsp;</div>'
    texte_HTML += "<h1>Élèves convoqués 2e fois sans résultat</h1>"
    for nom_classe in classe_a_convoquer2 :
        liste = a_convoquer2[a_convoquer2['Classe']==nom_classe]
        texte_HTML += nom_classe+"<br>"
        texte_HTML += liste.loc[:,['Nom du Participant','Prénom du Participant']].to_csv(index=False,header=False)+"<br>"



    repertoire = datetime.now().strftime('%Y-%m-%d')
    os.makedirs(repertoire, exist_ok=True)
    ecriture_sorties("Résumé certifications",repertoire,texte_HTML,"",sortie_html,sortie_pdf,False)
    

def dateAMint(dateISO):
    date_decoupe = dateISO.split('-')
    return int(date_decoupe[0]+date_decoupe[1])
    

def dateJMA(dateAMJ):
    date_decoupe = dateAMJ.split('-')
    return date_decoupe[2]+'/'+date_decoupe[1]+'/'+date_decoupe[0]

def date_mise_a_jour_github(nom_depot='Resultats-Campagne-PIX-orga'):
    
    r=requests.get('https://api.github.com/repos/zebobs/'+nom_depot+'/commits')
    date = r.json()[0]['commit']['committer']['date'][0:10]
    date = dateJMA(date)
    print("!!! La dernière mise à jour sur le  dépôt "+nom_depot+" date du "+ date)
    print("!!! Il est conseillé de mettre à jour si votre version est plus ancienne")


date_mise_a_jour_github('Resultats-Campagne-PIX-orga')

def is_oui(reponse: str):
    return reponse.upper() in ['O', 'OUI', 'Y', 'YES']
    
def main():
    sortie_html = False
    sortie_pdf = True
    sortie_csv = False
    
    
    username,password = donnees_perso()
    
    token_orga,user_id_orga=identification_orga(username,password)
    organisation_id=choix_organisation(token_orga,user_id_orga)

    traitement_certif_OK = is_oui(input("??? Voulez-vous suivre les certifications (o/n) ? Par défaut Non. "))
    if traitement_certif_OK: # Si on a pas de compte certif, le script plante
        token_certif,user_id_certif=identification_certif(username,password)    
        centre_id=choix_centre(token_certif)

    del username
    del password
        
    sortie_campagne_OK   = is_oui(input("??? Voulez-vous les fichiers des campagnes (o/n) ? Par défaut Non. "))
    archived_campagne_OK = is_oui(input("??? Voulez vous les campagnes archivées (o/n) ? Par défaut Non. "))
    only_mine_OK = is_oui(input("??? Voulez vous seulement vos campagnes (o/n) ? Par défaut Non. "))
    
    eleves_detail =liste_eleves_detail(token_orga,organisation_id)
    eleves = liste_eleves(eleves_detail)

    resultats_globaux=pd.DataFrame(columns=['Nom du Participant','Prénom du Participant','Classe','Connecté'])

    if only_mine_OK or archived_campagne_OK:
        campagnes=liste_campagnes(token_orga,organisation_id, only_me=only_mine_OK, also_archived=archived_campagne_OK)
    else:
        campagnes=liste_campagnes(token_orga,organisation_id)
    
    for campagne in campagnes :
        nom_campagne,resultats=lecture_campagne(token_orga,campagne)
        if nom_campagne!="":
            resultats,resultats_globaux = traitement_campagne(nom_campagne,resultats,resultats_globaux)
            if sortie_campagne_OK:
                sortie_par_classe(nom_campagne,resultats,eleves,sortie_html,sortie_pdf,sortie_csv)

    resultats = liste_identifiants(eleves_detail)
    sortie_par_classe("Identifiants PIX",resultats,eleves,sortie_html,sortie_pdf,sortie_csv,'paysage')

          


    if traitement_certif_OK:        
    
        resultats_certifications = pd.DataFrame(columns=['Nom du Participant','Prénom du Participant','Classe'])
        
        resultats,resultats_certifications = lecture_traitement_resultats_certif(token_orga,organisation_id,resultats_certifications,eleves)
        
        sessions = liste_sessions(token_certif,centre_id)
        candidats,resultats_certifications = liste_candidats(token_certif,centre_id,sessions,resultats_certifications)
        sessions_detail = liste_sessions_detail(sessions,candidats,'orga',sortie_html,sortie_pdf,False)
        sortie_par_classe("Suivi Certification",resultats_certifications,eleves,sortie_html,sortie_pdf,sortie_csv)    
        
        resultats_globaux = pd.merge(left=resultats_globaux,right=resultats_certifications,how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
        
        


    resultats_globaux = traitement_synthese(resultats_globaux,eleves)
    sortie_par_classe('Synthèse résultats Pix',resultats_globaux,eleves,sortie_html,sortie_pdf,True,'paysage')

if __name__ == '__main__':
    main()
